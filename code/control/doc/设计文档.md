# 设计文档

## 整体框架

总的来说，代码分为电机控制和状态控制（state_control.cpp: StateMachine）。

在电机控制循环（main.cpp: motor_control_loop() ）中，电机控制读取机器所处的状态，决定电机在这个状态下应该完成什么任务；在主循环（main.cpp: loop()）中，arduino 读取按钮和其他传感器的输入，通过状态机的 trigger_signal() 接口，向状态机发送信号使状态机转换状态。

机器运行中的信号是多样的，有外界的按钮信号，也有内部的传感器信号（上叉刀的压力传感器，（之后可能有的）上下叉刀运动范围边界的压力传感器），还有代码中为了使得状态机转换状态（force state transition）而发送的信号（如电机上升到预设的高度，电机控制循环主动发送 PEEL_START 信号）。从来源上分，粗略分为以上这几类，即用户、传感器、内部。从功能上分，一些信号需要传给状态机用于转移状态；一些信号则只是在电机控制循环中，用于控制电机运动的不同阶段（sub state），（如在 CLOSE STATE 中，上电机先向下直到压力传感器检测碰到水果，然后上电机不动，下电机再往上）。我们将两者分别称为 main signals 和 sub signals。

## 状态机

### state 的划分

原来想划分成 STOPPED, RUNNING, EXITING, CLEANING，但是后来把 RUNNING 细分为 CLOSE, UP, PEEL，而 EXITING 细分为 DOWN, OPEN，设计考虑是

*对于任一个状态中如果收到了外界的中断，应该被转换到的状态唯一的由初始态和外界中断的类型决定*

如用户在 RUNNING STATE 中按下了 start-stop 按钮，机器应当转换到 EXITING STATE，但是这对于电机控制并不友好：如果这时候已经夹上且向上移动了，则需要先向下移动放入碗中再松开；如果这时候还没夹上，则直接松开即可。这样的逻辑判断如果放到电机控制（motor_control_loop）中对于程序并不友好。

> 如果没有看懂上面的逻辑，可以再看一下下面的啰嗦。
> 
> 只考虑 start_stop 按钮，用户按下后，机器执行一系列操作，回到初始状态，其实也可以完全没有状态的划分。但是考虑一下程序员的心理呜呜，他需要写好多函数，代表机器的不同阶段，然后通过各种传感器的信号判断什么时候换到下一个函数。这就需要这个一直运行的电机控制循环（ main.cpp: motor_control_loop()）边控制电机，边注意各种信号。如果我们可以在主循环（main.cpp: loop()）中读取传感器，控制状态机；在电机控制循环中，只负责看现在是什么状态，执行相应的控制逻辑，就很优雅了。
> 
> 通过观察我们也发现，来自用户的信号（按下按钮）和来自内部的信号有本质的区别。
> 
> 用户的信号（和紧急停止信号）是中断式的，即在 STOPPED 状态下，突然让机器开始运作，或在 CLOSE 状态下，突然让机器停止作业，变为 OPEN；而内部的信号是可控的，也是顺序的，在内部信号下，机器是一个一个状态转换的。
> 
> 另外，中断式的信号在主循环中检测（之后可以直接用中断实现），而内部信号直接在电机控制循环中检测。
> 
> 这些观察使我想到，应该将两者分开，中断式信号就调用 StateMachine::trigger_signal(signal)，而非中断式信号可以直接用一个 StateMachine::next() 统一。

### 状态机（StateMachine）还有初始化作用

除了处理所有的信号和被 next 调用，来使得电机控制循环得知当前处在哪一状态之外，状态机还支持为切换到下一个状态做准备/初始化，如电机的转动方向，电机还需要移动的距离。

这一想法的起源是初始化电机的转动。如果没有初始化，那么需要在电机控制的第一行加上 set_direction 的函数调用，每次都要调用一遍，可以想见对性能的影响；而实际上，只要状态不变，一般来说是不需要改变方向的，我们只需要在进入这个状态时，加一个初始化函数，而调用这个函数最好的地方就是状态机。

后来发现，为了实现在 UP 状态中上升指定的距离，就必须维护一个变量表示还需要移动多少距离。这个也需要被初始化。这些在一个状态运行前需要被初始化，在状态执行中需要被调用来判断动作的变量被称为状态变量（state variables），他们可以同时被 main.cpp 和 state_control.cpp 访问，用全局变量的方式定义在 globals.hpp 中。


